fn main() {
  // 参照と借用
    // ゼロコスト抽象化

  // 借用
  let v1 = vec![1, 2, 3];
  let v2 = vec![1, 2, 3];
  let answer = foo(&v1, &v2);

  // // 参照時は借用状態ではベクタは全く変更できない。
  // let v = vec![];
  // foo2(&v);

  // &mut参照 「ミュータブルな参照」
  let mut x = 5;
  {
    let y = &mut x;
    *y += 1;
  }
  println!("{}", x);
    // ルール：借用はすべて所有者スコープより長く存続してはなりません。
    // ※だから {} でスコープを掘り下げて使っている。

  // 「借用」により回避される問題
    // それらのルールはデータ競合を回避します。
}

// 参照を渡す事で「所有権を借用」している。この場合、リソースは割り当て解除されない（あたりまえ）
fn foo(v1: &Vec<i32>, v2: &Vec<i32>) -> i32 {
  // v1とv2についての作業を行う
  // 答えを返す
  42
}

// fn foo2(v: &Vec<i32>) {
//   v.push(5);
//   // ERR: cannot borrow as mutable    
// }




